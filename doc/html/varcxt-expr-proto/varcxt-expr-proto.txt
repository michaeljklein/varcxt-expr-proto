-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/michaeljklein/varcxt-expr-proto#readme</a>
@package varcxt-expr-proto
@version 0.1.0.0

module Lib

-- | <tt>a</tt> is the <a>Cxt</a> of <tt>b</tt>
newtype (:=>) a b
Cxt :: (a -> b) -> (:=>) a b
[runCxt] :: (:=>) a b -> a -> b

-- | Variables of type <tt>a</tt> with ids of type <tt>v</tt>
data V v a
V :: v -> a -> V v a
[varId] :: V v a -> v
[varVal] :: V v a -> a

-- | Pattern bindings where variables have id type <tt>v</tt> and the
--   pattern is bound from matching on <tt>a</tt>'s to a result of type
--   <tt>b</tt>.
newtype Pattern v a b
Pattern :: (forall c d. (a -> Either c b) :=> (V v a -> (V v b :=> PExpr v d) -> Either c (PExpr v d))) -> Pattern v a b
[runPattern] :: Pattern v a b -> forall c d. (a -> Either c b) :=> (V v a -> (V v b :=> PExpr v d) -> Either c (PExpr v d))

-- | Identity pattern
idPatt :: Pattern v a a

-- | Expressions with variables, lambda/let binding, and literals
--   
--   Also with <a>Pattern</a>s, but not used much
data PExpr v a
[PLit] :: a -> PExpr v a
[PVar] :: (V v a :=> PExpr v a) :~: t -> PExpr v t
[PLambda] :: (a -> b) :~: t -> v -> Pattern v a a -> PExpr v (V v a :=> PExpr v b) -> PExpr v t
[PLet] :: v -> Pattern v a a -> PExpr v (V v a :=> PExpr v b) -> PExpr v a -> PExpr v b
[PToCxt] :: (a :=> b) :~: t -> PExpr v (a -> b) -> PExpr v t

-- | Expressions with variables, lambda/let binding, and literals
data Expr v a
[Lit] :: a -> Expr v a
[Var] :: (V v a :=> Expr v a) :~: t -> Expr v t
[Lambda] :: (a -> b) :~: t -> v -> Expr v (V v a :=> Expr v b) -> Expr v t
[Let] :: v -> Expr v (V v a :=> Expr v b) -> Expr v a -> Expr v b
[ToCxt] :: (a :=> b) :~: t -> Expr v (a -> b) -> Expr v t
[App] :: Expr v (a -> b) -> Expr v a -> Expr v b

-- | Evaluate a <a>PExpr</a>
--   
--   <pre>
--   λ&gt; eval (PLambda Refl () idPatt (PVar Refl)) (10 :: Int)
--   10
--   </pre>
evalp :: PExpr v a -> a

-- | Evaluate an <a>Expr</a>
--   
--   <pre>
--   λ&gt; eval (Lambda Refl () (Var Refl)) (10 :: Int)
--   10
--   </pre>
eval :: Expr v a -> a

-- | Lazy unpacking of <a>Right</a>
fromRightVoid :: Either Void a -> a
instance GHC.Base.Functor (Lib.V v)
instance GHC.Generics.Generic1 (Lib.V v)
instance GHC.Generics.Generic (Lib.V v a)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Lib.V v a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord v) => GHC.Classes.Ord (Lib.V v a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq v) => GHC.Classes.Eq (Lib.V v a)
instance Control.Arrow.Arrow (Lib.:=>)
instance Data.Profunctor.Unsafe.Profunctor (Lib.:=>)
instance Control.Category.Category (Lib.:=>)
instance GHC.Base.Monad ((Lib.:=>) a)
instance GHC.Base.Applicative ((Lib.:=>) a)
instance GHC.Base.Functor ((Lib.:=>) a)
instance Data.Foldable.Foldable (Lib.V v)
instance Data.Traversable.Traversable (Lib.V v)
instance Data.Bifunctor.Bifunctor Lib.V
instance Control.Comonad.Comonad (Lib.V v)
